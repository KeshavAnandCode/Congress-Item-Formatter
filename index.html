<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Resolution Formatter — Sections & Subsections (fixed parsing)</title>
<style>
  :root{
    --bg:#f0f2f5;
    --card:#ffffff;
    --ink:#111827;
    --muted:#6b7280;
    --accent:#1f2937;
    --primary:#4f46e5;
    --input-bg:#fafbfc;
    --input-border:#cbd5e1;
    --input-focus:#6366f1;
    --shadow-color:rgba(0,0,0,0.08);
  }

  html, body {
    margin:0; padding:0;
    background:var(--bg);
    color:var(--ink);
    font-family:Calibri, sans-serif;
    font-size:12pt;
    line-height:1.5;
  }

  .wrap { max-width:900px; margin:40px auto; padding:16px; }
  .card {
    background:var(--card);
    border-radius:16px;
    box-shadow:0 8px 24px var(--shadow-color);
    padding:32px 28px;
    display:flex;
    flex-direction:column;
    gap:24px;
  }

  header h1 { margin:0; font-size:28px; font-weight:700; color:var(--accent);}
  header p { margin-top:8px; color:var(--muted); font-size:15px; line-height:1.5; }

  textarea {
    width:100%;
    max-width:100%;
    min-height:280px;
    resize:vertical;
    padding:16px 18px;
    font-size:12pt;
    line-height:1.5;
    border:1px solid var(--input-border);
    border-radius:14px;
    background:var(--input-bg);
    color:var(--ink);
    outline:none;
    box-sizing:border-box;
    transition: all 0.3s ease;
  }

  textarea::placeholder {
    color: #9aa3b2;
    opacity:1;
  }

  textarea:focus {
    border-color:var(--input-focus);
    box-shadow:0 0 0 4px rgba(99,102,241,0.2);
    background:#fff;
  }

  .controls {
    display:flex;
    gap:16px;
    flex-wrap:wrap;
    align-items:center;
  }

  button {
    appearance:none;
    border:0;
    padding:12px 20px;
    border-radius:12px;
    cursor:pointer;
    background:var(--primary);
    color:#fff;
    font-weight:600;
    font-size:14px;
    transition:all 0.2s ease;
  }

  button:hover { background:#4338ca; }
  button.secondary { background:#e5e7eb; color:var(--ink); }
  button.secondary:hover { background:#d1d5db; }

  .preview {
    border:1px solid #e5e7eb;
    border-radius:14px;
    padding:24px;
    min-height:340px;
    background:#fff;
    overflow:auto;
    font-family:Calibri, sans-serif;
    font-size:12pt;
    line-height:1.5;
    box-shadow:0 4px 12px var(--shadow-color);
  }

  .resolution { width:100%; border-collapse:collapse; table-layout:fixed; }
  .resolution td { vertical-align:top; padding:10px 10px; word-break:break-word; } /* slightly larger vertical spacing */
  .resolution .kw { width:1.5in; font-weight:bold; }
  .resolution .tx { width:7in; }

  @media(max-width:800px) {
    .wrap { padding:12px; }
    .resolution .kw, .resolution .tx { display:block; width:100%; }
    .resolution td { padding:12px 6px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <h1>Resolution Formatter</h1>
      <p>Paste your line-numbered bill or resolution. Sections and subsections are formatted as a two-column table for Google Docs.</p>
    </header>

    <div class="controls">
      <button id="formatBtn">Format →</button>
      <button id="clearBtn" class="secondary">Clear</button>
      <button id="copyBtn" class="secondary">Copy formatted</button>
    </div>

    <textarea id="src" spellcheck="false" placeholder="Paste your bill or resolution here (without title)"></textarea>

    <div id="preview" class="preview" aria-live="polite"></div>
  </div>
</div>

<script>
/*
  Updated parseBlocks:
  - Strips ONLY leading whole-line numbers (^\d+\s+) so inline numbers like "$2 billion" are preserved.
  - Removes lines containing the enactment header and introduced-for-debate footer.
  - Properly handles SECTION lines that include inline subsections (splits them).
  - Subsections (A., B., C.) become rows with an empty left column and their text in the right column.
*/

function parseBlocks(text){
  const rawLines = text.split(/\n/); // preserve each physical line so we can strip leading numbers safely
  const blocks = [];
  let currentSection = null;

  // Patterns
  const sectionHeadRegex = /^(SECTION\s+\d+\.?)/i;                 // e.g. SECTION 2.
  const genericSectionRegex = /^(SECTION\s+\d+\.?|WHEREAS,|RESOLVED,|FURTHER RESOLVED,)/i;
  const subsectionStartRegex = /^([A-Z]\.)\s*/;                    // e.g. 'A. '
  const leadingLineNumberRegex = /^\d+\s+/;                        // leading line numbers to remove
  const enactedRegex = /^BE IT ENACTED BY THE CONGRESS HERE ASSEMBLED/i;
  const introducedRegex = /Introduced for Congressional Debate/i;

  for(let rawLine of rawLines){
    // Keep original whitespace-trimmed content
    let line = rawLine.trim();
    if(!line) continue;

    // Remove leading line number if present (only at start of this physical line)
    line = line.replace(leadingLineNumberRegex, "");

    // Skip unwanted boilerplate lines anywhere they appear
    if(enactedRegex.test(line)) continue;
    if(introducedRegex.test(line)) continue;

    // If the line begins with a recognized SECTION / WHEREAS / RESOLVED token
    let secMatch = line.match(genericSectionRegex);

    // Special handling when line contains SECTION followed by inline subsections (e.g. "SECTION 2. A. ... B. ...")
    if(secMatch){
      // Push previous section
      if(currentSection) blocks.push(currentSection);

      // Identify the exact section token (SECTION 2. or WHEREAS, etc.)
      const token = secMatch[1];
      // Remove the token from the line to examine the remainder
      let remainder = line.slice(line.indexOf(token) + token.length).trim();

      // Create a new currentSection container
      currentSection = { kw: token, text: "", subsections: [] };

      if(!remainder){
        // nothing after SECTION token on this line — continue to next lines to collect text
        continue;
      }

      // If remainder starts with a subsection (A., B., etc.) or contains multiple subsections inline,
      // split the remainder into parts before each subsection marker.
      const parts = remainder.split(/(?=(?:[A-Z]\.)\s)/g); // split but keep the marker at start of each part

      // If the first part doesn't start with a subsection token, treat it as section main text
      if(parts.length > 0 && !subsectionStartRegex.test(parts[0])){
        currentSection.text = parts[0].trim();
      }

      // Any subsequent parts that start with a subsection token become subsections
      for(let p of parts){
        const ptrim = p.trim();
        const sm = ptrim.match(subsectionStartRegex);
        if(sm){
          // remove the subsection token from text for storage
          const subkw = sm[1]; // e.g. 'A.'
          const subtext = ptrim.slice(sm[0].length).trim();
          currentSection.subsections.push({ kw: subkw, text: subtext });
        }
      }

      continue;
    }

    // If the line itself starts with a subsection marker (A., B., etc.)
    const subLineMatch = line.match(subsectionStartRegex);
    if(subLineMatch && currentSection){
      const subkw = subLineMatch[1];
      const subtext = line.slice(subLineMatch[0].length).trim();
      currentSection.subsections.push({ kw: subkw, text: subtext });
      continue;
    }

    // If none of the above:
    if(currentSection){
      // Append this line to the most recent subsection if one exists, otherwise to the section text
      if(currentSection.subsections.length > 0){
        const lastSub = currentSection.subsections[currentSection.subsections.length - 1];
        // join with a space to preserve sentences across wrapped lines
        lastSub.text = (lastSub.text ? lastSub.text + " " : "") + line;
      } else {
        currentSection.text = (currentSection.text ? currentSection.text + " " : "") + line;
      }
    } else {
      // If no current section exists, treat this as freeform top-level content
      blocks.push({ kw: "", text: line, subsections: [] });
    }
  }

  // Push last section if present
  if(currentSection) blocks.push(currentSection);
  return blocks;
}

function buildHTML(blocks){
  const rows = [];
  for(const sec of blocks){
    rows.push(`<tr><td class="kw">${escapeHTML(sec.kw)}</td><td class="tx">${escapeHTML(sec.text)}</td></tr>`);
    for(const sub of sec.subsections){
      rows.push(`<tr><td class="kw"></td><td class="tx">${escapeHTML(sub.kw)} ${escapeHTML(sub.text)}</td></tr>`);
    }
  }
  return `<table class="resolution" role="presentation"><tbody>${rows.join('\n')}</tbody></table>`;
}

function escapeHTML(s){
  return (s||"").replace(/[&<>\"]|\u00A0/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\u00A0':' ' }[ch]));
}

function formatNow(){
  const src = document.getElementById('src').value;
  const blocks = parseBlocks(src);
  document.getElementById('preview').innerHTML = buildHTML(blocks);
}

async function copyFormatted(){
  const preview = document.getElementById('preview');
  if(!preview.firstElementChild){ formatNow(); }
  const html = preview.innerHTML.replace('<table','<table style="width:100%; border-collapse:collapse; table-layout:fixed; font-family:Calibri,sans-serif; font-size:12pt; line-height:1.5;"')
    .replaceAll('class="kw"','style="width:1.5in; font-weight:bold; vertical-align:top; padding:10px 8px;"')
    .replaceAll('class="tx"','style="width:7in; vertical-align:top; padding:10px 8px;"');

  const blobHTML = new Blob([html], {type:"text/html"});
  const plain = preview.innerText;
  const blobText = new Blob([plain], {type:"text/plain"});

  try{
    await navigator.clipboard.write([new ClipboardItem({"text/html": blobHTML, "text/plain": blobText})]);
    flash("Copied! Paste into Google Docs.");
  }catch(err){
    const range = document.createRange();
    range.selectNodeContents(preview);
    const sel = window.getSelection();
    sel.removeAllRanges(); sel.addRange(range);
    document.execCommand('copy');
    sel.removeAllRanges();
    flash("Copied! Paste into Google Docs.");
  }
}

function flash(msg){
  const b = document.getElementById('copyBtn');
  const old = b.textContent;
  b.textContent = msg;
  b.disabled = true;
  setTimeout(()=>{ b.textContent = old; b.disabled = false; }, 1400);
}

document.getElementById('formatBtn').addEventListener('click', formatNow);
document.getElementById('copyBtn').addEventListener('click', copyFormatted);
document.getElementById('clearBtn').addEventListener('click', ()=>{
  document.getElementById('src').value='';
  document.getElementById('preview').innerHTML='';
});
window.addEventListener('load', formatNow);
</script>
</body>
</html>
